/**
 * 1. 为什么会出现这个路径？
/_nuxt/ 是 Nuxt 3 预留的虚拟路径，用于发布所有编译后的静态资源（JS、CSS 等）。 通常是因为以下原因触发了对该根路径的访问：

浏览器插件：有些插件（如密码管理器、SEO 工具）会尝试探测资源目录的根路径。
浏览器预加载：浏览器有时会尝试探测基础路径以进行优化。
开发工具：HMR（热更新）或其他开发端工具偶尔会向该路径发送探测请求。
2. 为什么会报错？
在 Nuxt 生态中，底层的服务器引擎叫做 Nitro。

由于 /_nuxt/ 目录本身没有像 index.html 这样的索引文件，所以请求到这里时，Nitro 找不到对应的内容。
在开发模式下，Nitro 为了方便开发者排查“资源丢失”的问题，会将所有“未处理（Unhandled）”的 404 请求直接打印到终端控制台，并标记为红色 Error。
3. 之前的修复为什么“没好”？
我第一次尝试时，在中间件里显式设置了 setResponseStatus(event, 404)。

虽然返回了结果，但状态码依然是 404。
Nitro 的逻辑是：只要状态码是 404，它依然会认为这是一次“失败的、未处理的访问”，从而继续打印报错。
4. 现在的修复原理是什么？
现在的代码改成了直接返回 { status: 'OK' }。

这会默认返回 200 OK 状态码。
在 Nuxt 中间件逻辑中，只要中间件返回了非空的值，Nitro 就会认为这个请求已经被“拦截并成功处理”了。
既然请求被处理了，它就不会进入 Nitro 的错误捕捉逻辑，也就不会在你的控制台显示红色的报错了。

*/

export default defineEventHandler((event) => {
    // 拦截对 Nuxt 资源根目录（/_nuxt/）的请求
    // 此请求在开发环境下经常由浏览器插件或 Prefetch 触发，若不处理会因找不到文件而报"unhandled" 404 错误
    // 返回一个简单的 200 OK 响应
    // 只要中间件返回了值（且未设为错误状态），Nitro 就会认为该请求已处理，从而消除控制台报错
    if (event.path === '/_nuxt' || event.path === '/_nuxt/') {
        return { status: 'OK', message: 'Silenced' }
    }
})
